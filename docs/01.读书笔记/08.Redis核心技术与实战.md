---
title: Redis核心技术与实战
date: 2023-08-03 21:11:13
permalink: /pages/02f601/
---
> 基于版本6.x

## 数据结构
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652862617944-af974de2-07f6-4461-9b4a-0004cf1b3161.png#clientId=uc1d26104-57d3-4&from=paste&height=793&id=u265772a0&originHeight=1189&originWidth=4003&originalType=binary&ratio=1&rotation=0&showTitle=false&size=641753&status=done&style=shadow&taskId=ue220a146-5ea4-4ba8-976b-78bed258cae&title=&width=2668.6666666666665)可以看到，String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、 Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是**一个键对应了一个集合的数据**。

### 哈希表
为了实现从键到值的快速访问，Redis 使用了**一个哈希表来保存所有键值对**。
一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。
在下图中，可以看到，哈希桶中的 entry 元素中保存了*key和*value指针，分别指向了 实际的键和值，这样一来，即使值是一个集合，也可以通过*value指针被查找到。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652863931514-17afac9c-e440-4e6d-8a34-70581c92c1c4.png#clientId=uc1d26104-57d3-4&from=paste&height=584&id=u6f663c0c&originHeight=876&originWidth=1775&originalType=binary&ratio=1&rotation=0&showTitle=false&size=276890&status=done&style=shadow&taskId=u8154d1cf-2f87-499a-ad99-f6af07058b1&title=&width=1183.3333333333333)
因为这个哈希表保存了所有的键值对，所以，我也把它称为**全局哈希表**。虽然，哈希表具有的 O(1) 复杂度和快速查找特性，但是，时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是**哈希表的冲突问题和 rehash 可能带来的操作阻塞**。

Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指**同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接**。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652864249002-e4921273-bdd2-4816-9ba5-744546ab5510.png#clientId=uc1d26104-57d3-4&from=paste&height=729&id=u84eceda0&originHeight=1094&originWidth=1235&originalType=binary&ratio=1&rotation=0&showTitle=false&size=343145&status=done&style=shadow&taskId=u2a2e717f-5fcd-4d38-9589-cfe053de86c&title=&width=823.3333333333334)
#### rehash
如果冲突太多，就成长链表了，复杂度就退化为近似 O(n) 了，这是不能接受的。
所以，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个 桶中的冲突。
其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希 表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍； 
2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；
3. 释放哈希表 1 的空间。

到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来 的哈希表 1 留作下一次 rehash 扩容备用。
这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都 迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据 了。为了避免这个问题，Redis 采用了**渐进式 rehash**。
简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝 到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。

#### 哈希表的扩展与收缩
当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作（定时任务，默认100毫秒）：

- 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1。
- 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。
- 当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作
```shell
# 负载因子=哈希表已保存节点数量/哈希表大小
load_factor = ht[0].used / ht[0].size
```

### 压缩列表
压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同 的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的 偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652949896953-d90366a5-a7f3-41d8-93d5-b75bdf86c0ed.png#clientId=u95d8803e-249f-4&from=paste&height=211&id=u5139f383&originHeight=317&originWidth=1584&originalType=binary&ratio=1&rotation=0&showTitle=false&size=106643&status=done&style=shadow&taskId=uaaa2f045-63d6-4b13-8d4d-988012d6209&title=&width=1056)
在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段 的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查 找，此时的复杂度就是 O(N) 了。


### 跳表
有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，跳 表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652949945295-d3a4a245-d21c-4546-a53b-6e1b449e0e80.png#clientId=u95d8803e-249f-4&from=paste&height=751&id=uc6c19c28&originHeight=1127&originWidth=1879&originalType=binary&ratio=1&rotation=0&showTitle=false&size=365472&status=done&style=shadow&taskId=u56af2919-6504-4f64-a07c-32e9ba0174a&title=&width=1252.6666666666667)

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652949950243-6ad16e7a-13f3-43c7-86dd-902e765ae28b.png#clientId=u95d8803e-249f-4&from=paste&height=501&id=u4d6d9767&originHeight=751&originWidth=1334&originalType=binary&ratio=1&rotation=0&showTitle=false&size=245393&status=done&style=shadow&taskId=u5a70f25c-48e4-4ecb-99ed-d678e91dc5d&title=&width=889.3333333333334)

## 单线程 Redis 为什么那么快
我们通常说，Redis 是单线程，主要是指** Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程**。 但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

**Redis基本IO模型**
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652950592898-06295ec8-ca55-48cb-a107-fd2b0b90eaf5.png#clientId=u95d8803e-249f-4&from=paste&height=996&id=u883b1155&originHeight=1494&originWidth=2704&originalType=binary&ratio=1&rotation=0&showTitle=false&size=644027&status=done&style=shadow&taskId=u8d18c1cc-65ac-4c7e-86c9-019ba681970&title=&width=1802.6666666666667)
**非阻塞模式**
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652950627473-90572f14-60b7-48f9-b87d-d561b274cfaf.png#clientId=u95d8803e-249f-4&from=paste&height=720&id=u16b2f81c&originHeight=1080&originWidth=3745&originalType=binary&ratio=1&rotation=0&showTitle=false&size=726139&status=done&style=shadow&taskId=u66af10b7-f3af-48d8-b06d-33915150c80&title=&width=2496.6666666666665)
**I/O 多路复用**
为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即**针对不同事件的发生，调用相应的处理函数**。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652950640407-6156fdd1-7375-4cd9-863e-475979346b21.png#clientId=u95d8803e-249f-4&from=paste&height=1502&id=u70b8b196&originHeight=2253&originWidth=3473&originalType=binary&ratio=1&rotation=0&showTitle=false&size=954957&status=done&style=shadow&taskId=u4883ba65-bae4-45cb-970c-b8e82883bc8&title=&width=2315.3333333333335)


## AOF
说到日志，我们比较熟悉的是数据库的写前日志（Write Ahead Log, WAL），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。不过， AOF 日志正好相反，它是写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652950785427-2cceb461-ec15-4af5-9f15-6bb8bee99665.png#clientId=u95d8803e-249f-4&from=paste&height=1193&id=u38e92699&originHeight=1790&originWidth=3222&originalType=binary&ratio=1&rotation=0&showTitle=false&size=453274&status=done&style=shadow&taskId=u5014d090-d358-4555-ae9e-364aa2619af&title=&width=2148)
AOF记录的是 Redis 协议的命令
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652950832962-1e44e8dd-fa2e-412e-8981-188ff45d325d.png#clientId=u95d8803e-249f-4&from=paste&height=1501&id=u6eb53303&originHeight=2251&originWidth=3097&originalType=binary&ratio=1&rotation=0&showTitle=false&size=413906&status=done&style=shadow&taskId=u220deeef-ff63-47c3-8087-f81f32fe7cc&title=&width=2064.6666666666665)
### 为什么先执行命令再写日志

- 为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。
- 它是在命令执行后才记录日志，所以不会阻塞当前的写操作。

### 三种写回策略

- Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘； 
- Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘； 
- No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652951022781-6079336d-d767-49ab-ab57-5a3d9e1c94cf.png#clientId=u95d8803e-249f-4&from=paste&height=455&id=uc6ab8c5c&originHeight=683&originWidth=2287&originalType=binary&ratio=1&rotation=0&showTitle=false&size=577159&status=done&style=shadow&taskId=ubba93cdc-3721-4c4b-9001-c4286f33893&title=&width=1524.6666666666667)
这里的“性能问题”，主要在于以下三个方面：

- 文件系统本身对文件大小有限制， 无法保存过大的文件；
- 如果文件太大，之后再往里面追加命令记录的话，效率也会变低；
- 如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如 果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。

### AOF 重写机制
为了解决 AOF 文件体积膨胀的问题，Redis 提供了 AOF 文件重写（rewrite）功能。通过该功能，Redis 服务器可以创建一个新的 AOF 文件来替代现有的 AOF 文件，新旧两个 AOF 文件所保存的数据库状态相同，但新 AOF 文件不包含任何浪费空间的冗余命令，所以新 AOF 文件的体积通常会比旧 AOF 文件的提交要小得多
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652951866680-f2f4caea-d08f-469c-97ab-b150c0fb0216.png#clientId=u95d8803e-249f-4&from=paste&height=726&id=u4c882bd3&originHeight=1089&originWidth=4004&originalType=binary&ratio=1&rotation=0&showTitle=false&size=672070&status=done&style=shadow&taskId=u9abd1c8e-caaf-4679-b380-1c53ff958e8&title=&width=2669.3333333333335)

- 子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。
- 子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。

在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：

1. 执行客户端发来的命令。
2. 将执行后的写命令追加到AOF缓冲区。
3. 将执行后的写命令追加到AOF重写缓冲区。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652954195068-0b8b0104-e938-4aec-bd4f-87db0695d9c7.png#clientId=u95d8803e-249f-4&from=paste&height=150&id=ud8b8383a&originHeight=225&originWidth=594&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56898&status=done&style=shadow&taskId=u0dbc9c85-c961-4f3b-b0bb-634bd50703b&title=&width=396)
这样一来可以保证：

- AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。
- 从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。

当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用一个信号处理函数，并执行以下工作：

1. 将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。
2. 对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换。

这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。
在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1652954448989-ed359412-4832-48b3-b54b-46682f1ca825.png#clientId=u95d8803e-249f-4&from=paste&height=1249&id=u0f3a61cd&originHeight=1874&originWidth=4001&originalType=binary&ratio=1&rotation=0&showTitle=false&size=941497&status=done&style=shadow&taskId=u60662ddd-32d8-4c81-9ba0-4dd53f800d3&title=&width=2667.3333333333335)

#### 触发条件
AOF 重写可以由用户通过调用 `BGREWRITEAOF` 手动触发。
另外，服务器在 AOF 功能开启的情况下，会维持以下三个变量：

- 记录当前 AOF 文件大小的变量 aof_current_size 。
- 记录最后一次 AOF 重写之后，AOF 文件大小的变量 aof_rewirte_base_size 。
- 增长百分比变量 aof_rewirte_perc 。

每次当 serverCron 函数执行时，它都会检查以下条件是否全部满足，如果是的话，就会触发 自动的 AOF 重写：

1. 没有 BGSAVE 命令在进行。
2. 没有 BGREWRITEAOF 在进行。
3. 当前 AOF 文件大小大于 server.aof_rewrite_min_size （默认值为 1 MB）。
4. 当前 AOF 文件大小和最后一次 AOF 重写后的大小之间的比率大于等于指定的增长百分比。

默认情况下，增长百分比为 100% ，也即是说，如果前面三个条件都已经满足，并且当前 AOF 文件大小比最后一次 AOF 重写时的大小要大一倍的话，那么触发自动 AOF 重写。

## RDB

- 如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。
- 只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653620756809-4f4cc38e-ecb5-409b-a23b-6b1203aded9a.png#clientId=u9a61cdfb-3539-4&from=paste&height=219&id=u5526ba9d&originHeight=328&originWidth=436&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68903&status=done&style=shadow&taskId=ufb596845-8c60-43e8-9a13-955519e70da&title=&width=290.6666666666667)
对 Redis 来说，它实现类似照片记录效果的方式，就是把某一时刻的状态以文件的形式写到磁盘上，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件，其中，RDB 就是 Redis DataBase 的缩写。
Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是**全量快照**

Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。

- save：在主线程中执行，会导致阻塞；
- bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置

### bgsave
在 bgsave 时，为了保证快照完整性，理论上，主进程它只能处理读操作，因为不能修改正在执行快照的数据。为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。
简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。
> “这块数据就会被复制一份，生成该数据的副本”，这个操作在实际执行过程中，是子进程复制了主线程的页表，所以通过页表映射，能读到主线程的原始数据，而当有新数据写入或数据修改时，主线程会把新数据或修改后的数据写到一个新的物理内存地址上，并修改主线程自己的页表映射。所以，子进程读到的类似于原始数据的一个副本，而主线程也可以正常进行修改。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653292507668-bccc3a42-995e-4ced-bfcf-641696cda800.png#clientId=u005e9c11-4202-4&from=paste&height=1500&id=u4a3eccec&originHeight=2250&originWidth=4000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=654356&status=done&style=shadow&taskId=uf22b7bce-3e88-4714-9dbb-89a2e15a4f8&title=&width=2666.6666666666665)
Redis 会使用 bgsave 对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主线程同时可以修改数据。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653553025287-ce7b9caa-d33c-4d55-a7be-d82082d3201f.png#clientId=u18744dfa-f3be-4&from=paste&height=1337&id=u707b0355&originHeight=2005&originWidth=2725&originalType=binary&ratio=1&rotation=0&showTitle=false&size=714018&status=done&style=shadow&taskId=u7cb9433f-d72e-4686-bcd0-3327e966e97&title=&width=1816.6666666666667)
### 多久生成一次快照
如果频繁地执行全量快照，也会带来两方面的开销

- 频繁将全量数据写入磁盘，会给磁盘带来很大压力
- bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。

不同版本配置[https://redis.io/docs/manual/config/](https://redis.io/docs/manual/config/)
```shell
#6.2
save 3600 1
save 300 100
save 60 10000
#6.0
save 900 1
save 300 10
save 60 10000
```
我们可以做增量快照，所谓增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。
Redis 4.0 中提出了一个**混合使用 AOF 日志和内存快照**的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。
这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653293572415-a661d303-4b20-4fa7-bdc6-3d330d2afea9.png#clientId=u005e9c11-4202-4&from=paste&height=1455&id=u1067a430&originHeight=2183&originWidth=3508&originalType=binary&ratio=1&rotation=0&showTitle=false&size=674787&status=done&style=shadow&taskId=u7eb95372-8cf7-4a1b-bd3d-9010f39b8c4&title=&width=2338.6666666666665)

### BGSAVE命令执行时的服务器状态

- 首先，在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。
- 其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件。
- 最后，BGREWRITEAOF和BGSAVE两个命令不能同时执行：
   - 如果BGSAVE命令正在执行，那么客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行。
   - 如果BGREWRITEAOF命令正在执行，那么客户端发送的BGSAVE命令会被服务器拒绝。

因为BGREWRITEAOF和BGSAVE两个命令的实际工作都由子进程执行，所以这两个命令在操作方面并没有什么冲突的地方，不能同时执行它们只是一个性能方面的考虑——并发出两个子进程，并且这两个子进程都同时执行大量的磁盘写入操作，这怎么想都不会是一个好主意。

### RDB文件结构
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653620977078-698c5af6-cfe7-4998-88f0-b36660c149dc.png#clientId=u9a61cdfb-3539-4&from=paste&height=41&id=udde482c0&originHeight=40&originWidth=566&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20987&status=done&style=shadow&taskId=u63cae98c-e63a-4d56-b9e4-6647f1067b6&title=&width=583.3333435058594)

- 五个字节的"REDIS"字符串。
- 四个字节的版本号（db_version）。
- 一个字节的EOF常量。
- 八个字节的校验和（check_sum）

详细说明：

- RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着“REDIS”五个字符（非C语言的字符，不带有\0结尾）。通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件。
- db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如"0006"就代表RDB文件的版本为第六版。
   - 如果服务器的数据库状态为空（所有数据库都是空的），那么这个部分也为空，长度为0字节。
   - 如果服务器的数据库状态为非空（有至少一个数据库非空），那么这个部分也为非空，根据数据库所保存键值对的数量、类型和内容不同，这个部分的长度也会有所不同。
- EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。
- check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。
## 主从数据同步
我们总说的 Redis 具有高可靠性，又是什么意思呢？其实，这里有两层含义：
一是**数据尽量少丢失**，二**是服务尽量少中断**。AOF 和 RDB 保证了前者，而对于后者，Redis 的做法就是**增加副本冗余量**，将一份数据同时保存在多个实例上。即使有一个实例出现了故障，需要过一段时间才能恢复，其他实例也可以对外提供服务，不会影响业务使用。

Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。

- 读操作：主库、从库都可以接收；
- 写操作：首先到主库执行，然后，主库将写操作同步给从库。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653293992551-fceb6c23-40b2-432e-b7d5-c3edcc1f25e3.png#clientId=u005e9c11-4202-4&from=paste&height=1413&id=ue3538b65&originHeight=2119&originWidth=3214&originalType=binary&ratio=1&rotation=0&showTitle=false&size=504704&status=done&style=shadow&taskId=ub71c1a7c-5b1e-4679-9f0a-ff5986479a0&title=&width=2142.6666666666665)
_Redis主从库和读写分离_
为什么只有主库能接受写操作？

- 如果对三个实例上的同一个数据（k1）进行修改，请求落到不同的实例上，那么数据就不一致了（v1、v2、v3）
- 而主从库模式一旦采用了读写分离，所有数据的修改只会在主库上进行，不用协调三个实例。主库有了最新的数据后，会同步给从库，这样，主从库的数据就是一致的。

### 主从库第一次同步
当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。例如，现在有实例 1（ip：172.16.19.3）和实例 2（ip：172.16.19.5），我们在实例 2 上执行以下这个命令后，实例 2 就变成了实例 1 的从库，并从实例 1 上复制数据：
```shell
replicaof 172.16.19.3 6379
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653295809773-9d5fef22-207c-4b69-94b0-a88d56d2cab8.png#clientId=u005e9c11-4202-4&from=paste&height=1117&id=ue55885e1&originHeight=1676&originWidth=3765&originalType=binary&ratio=1&rotation=0&showTitle=false&size=744238&status=done&style=shadow&taskId=u8c30fd22-d985-4bd6-9da3-18534decc0f&title=&width=2510)
_主从库第一次同步的流程_

- 第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，**从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了**

具体来说，从库给主库发送 `psync` 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。

   - runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。
   - offset，此时设为 -1，表示第一次复制。

主库收到 psync 命令后，会用 `FULLRESYNC` 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。
这里有个地方需要注意，**FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库**。

- 在第二阶段，**主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载**。这个过程依赖于内存快照生成的 RDB 文件。

具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。
在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 `replication buffer`，记录RDB 文件生成后收到的所有写操作。

- 最后，也就是第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。


### 主-从-从 模式
通过分析主从库间第一次数据同步的过程，你可以看到，一次全量复制中，对于主库来说，需要完成两个耗时的操作：**生成 RDB 文件和传输 RDB 文件**。
如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。我们可以**通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。**
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653300712987-26789f30-1f15-4e15-b1ff-d13319bdef67.png#clientId=u005e9c11-4202-4&from=paste&height=1194&id=ua22dfc45&originHeight=1791&originWidth=3543&originalType=binary&ratio=1&rotation=0&showTitle=false&size=446561&status=done&style=shadow&taskId=u4030feda-4454-40f0-af9e-4646480e520&title=&width=2362)
那么，一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为**基于长连接的命令传播**
### 网络断连
在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。
从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。

那么，增量复制时，主从库之间具体是怎么保持同步的呢？这里的奥妙就在于 `repl_backlog_buffer` 这个缓冲区。我们先来看下它是如何用于增量命令的同步的。当主从库断连后，主库会把断连期间收到的写操作命令，写入 `replication buffer`，同时也会把这些操作命令也写入 `repl_backlog_buffer` 这个缓冲区

- repl_backlog_buffer 

设置复制积压大小。积压是一个积累的缓冲区副本断开一段时间后的副本数据，这样当一个副本想要重新连接，通常不需要完全重新同步，而是部分重新同步就足够了，只需将部分数据传递给副本断开连接时错过。复制积压越大，副本可以承受的时间越长断开连接，稍后可以执行部分重新同步。只有至少有一个副本连接时才会分配积压。多个从库共享一个 repl_backlog_buffer 

- replication buffer
[https://redis.com/blog/top-redis-headaches-for-devops-replication-buffer/](https://redis.com/blog/top-redis-headaches-for-devops-replication-buffer/)
复制缓冲区是在从 Redis 服务器与主服务器同步时保存数据的内存缓冲区（主库对每个从库单独生成buffer，私有，不共享）。在完全主从同步中，在同步的初始阶段对数据执行的更改由主服务器保存在复制缓冲区中。初始阶段完成后，将缓冲区的内容发送到从站。在这个过程中可以使用的缓冲区大小是有限制的，当达到最大值时，会导致复制从头开始，正如我们关于无限 Redis 复制循环的帖子中所述。为了防止这种情况发生，缓冲区的初始配置需要根据复制过程中预期更改的数量和类型进行。例如，较小的更改量和/或更改中的较小数据可以通过较小的缓冲区来解决，而如果有很多更改和/或更改很大，则需要大缓冲区。更全面的解决方案需要将缓冲区设置为非常高的级别，以抵消冗长或繁重的复制过程最终会耗尽缓冲区（如果后者太小）的可能性。最终，该解决方案需要微调手头的特定数据库。

总结：**repl_backlog_buffer 用来存放从库断开连接后，主库这段时间执行的数据（共享）；replication buffer 是从库加载主库 RDB 文件，主库这段时间执行的数据（私有）**
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653553131131-f5f064a6-be1f-4eb4-95f6-2de472030362.png#clientId=u18744dfa-f3be-4&from=paste&height=1080&id=u9b5ffd15&originHeight=1620&originWidth=2109&originalType=binary&ratio=1&rotation=0&showTitle=false&size=321248&status=done&style=shadow&taskId=ufd13cde1-1c31-4e76-86f0-5fc5167013d&title=&width=1406)

repl_backlog_buffer 是一个环形缓冲区，**主库会记录自己写到的位置，从库则会记录自己已经读到的位置**
刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是 master_repl_offset。主库接收的新写操作越多，这个值就会越大。
同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 slave_repl_offset 也在不断增加。正常情况下，这两个偏移量基本相等。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653377491269-eb58f2da-02d4-4889-b555-fee41785efb7.png#clientId=ud9bc8da5-4eba-4&from=paste&height=710&id=u7e193ddf&originHeight=1065&originWidth=4000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=658943&status=done&style=shadow&taskId=ufa6570dc-feee-4c22-b741-5b9c637fe2d&title=&width=2666.6666666666665)
主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距。

如果 master_repl_offset 大于 slave_repl_offset。此时，主库只用把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库就行。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653377676454-2af570fa-aa08-4ebf-8edb-9468d95800ab.png#clientId=ud9bc8da5-4eba-4&from=paste&height=1126&id=ub1ac4f59&originHeight=1689&originWidth=3328&originalType=binary&ratio=1&rotation=0&showTitle=false&size=533558&status=done&style=shadow&taskId=u97091b03-8a30-45bb-98f1-ea50481c760&title=&width=2218.6666666666665)
**如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。**

因此，我们要想办法避免这一情况，一般而言，我们可以调整 `repl_backlog_size` 这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：_缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小_。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 _repl_backlog_size = 缓冲空间大小 * 2_，这也就是 repl_backlog_size 的最终值。
举个例子，如果主库每秒写入 2000 个操作，每个操作的大小为 2KB，网络每秒能传输1000 个操作，那么，有 1000 个操作需要缓冲起来，这就至少需要 2MB 的缓冲空间。否则，新写的命令就会覆盖掉旧操作了。为了应对可能的突发压力，我们最终把repl_backlog_size 设为 4MB。
`repl_backlog_size`**默认值 1M **，记得修改。如果从库断连后，期间操作超过 1M，那么就要重新全量复制了

---

Redis 中的子进程和后台线程
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653552783462-9ca84ae0-dc09-4657-8525-2463d617ff01.png#clientId=u18744dfa-f3be-4&from=paste&height=881&id=u65fb4668&originHeight=1322&originWidth=2210&originalType=binary&ratio=1&rotation=0&showTitle=false&size=280466&status=done&style=shadow&taskId=u9a054d7f-0ef0-403b-9bdc-d43e4a795c1&title=&width=1473.3333333333333)
## 哨兵机制
### 哨兵机制的基本流程
哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。

- 监控是指哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始**自动切换主库**的流程。
- 首先是执行哨兵的第二个任务，选主。主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。这一步完成后，现在的集群里就有了新主库。
- 然后，哨兵会执行最后一个任务：通知。在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653378996920-d4022465-fb16-4e10-abd7-0cbfb2cfd154.png#clientId=ud9bc8da5-4eba-4&from=paste&height=679&id=u059355f0&originHeight=1018&originWidth=2890&originalType=binary&ratio=1&rotation=0&showTitle=false&size=245254&status=done&style=shadow&taskId=uea4fb003-c752-4df6-b703-cc7e8083983&title=&width=1926.6666666666667)


### 主观下线和客观下线
哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。
如果检测的是从库，那么，哨兵简单地把它标记为“主观下线”就行了，因为从库的下线影响一般不太大，集群的对外服务不会间断。
但是，如果检测的是主库，那么，哨兵还不能简单地把它标记为“主观下线”，开启主从切换。因为很有可能存在这么一个情况：那就是哨兵误判了，其实主库并没有故障。可是，一旦启动了主从切换，后续的选主和通知操作都会带来额外的计算和通信开销。
通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653379520019-c1c790ef-0a3e-463d-b780-789c9116598e.png#clientId=ud9bc8da5-4eba-4&from=paste&height=944&id=u238aa155&originHeight=1416&originWidth=3807&originalType=binary&ratio=1&rotation=0&showTitle=false&size=456889&status=done&style=shadow&taskId=uaf029580-4e23-40a1-9522-6a807c6d38e&title=&width=2538)
简单来说，**“客观下线”的标准就是，当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”**。这样一来，就可以减少误判的概率，也能避免误判带来的无谓的主从库切换。（当然，有多少个实例做出“主观下线”的判断才可以，可以由 Redis 管理员自行设定）。

### 如何选定新主库
一般来说，我把哨兵选择新主库的过程称为“**筛选 + 打分**”。简单来说，我们在多个从库中，先按照一定的筛选条件，把不符合条件的从库去掉。然后，我们再按照一定的规则，给剩下的从库逐个打分，将得分最高的从库选为新主库
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653379677840-d8146c30-fd4c-4e55-8faa-b41643e3e88e.png#clientId=ud9bc8da5-4eba-4&from=paste&height=1162&id=uc810a2cb&originHeight=1743&originWidth=3671&originalType=binary&ratio=1&rotation=0&showTitle=false&size=443615&status=done&style=shadow&taskId=u3cfa194f-442a-42ec-8bcb-e59504bdd7d&title=&width=2447.3333333333335)
我们可以分别按照三个规则依次进行三轮打分，这三个规则分别是从**库优先级**、**从库复制进度**以及**从库 ID 号**。只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。如果没有出现得分最高的从库，那么就继续进行下一轮。

- 第一轮：优先级最高的从库得分高。

用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级。比如，你有两个从库，它们的内存大小不一样，你可以手动给内存大的实例设置一个高优先级。在选主时，哨兵会给优先级高的从库打高分，如果有一个从库优先级最高，那么它就是新主库了。如果从库的优先级都一样，那么哨兵开始第二轮打分。

- 第二轮：和旧主库同步程度最接近的从库得分高。

这个规则的依据是，如果选择和旧主库同步最接近的那个从库作为主库，那么，这个新主库上就有最新的数据。主从库同步时有个命令传播的过程。在这个过程中，主库会用 master_repl_offset 记录当前的最新写操作在 repl_backlog_buffer 中的位置，而从库会用 slave_repl_offset 这个值记录当前的复制进度。如果在所有从库中，有从库的 slave_repl_offset 最接近 master_repl_offset，那么它的得分就最高，可以作为新主库。如果有多个同步程度最接近的从库，那么哨兵开始第三轮打分。

- 第三轮：ID 号小的从库得分高。

每个实例都会有一个 ID，这个 ID 就类似于这里的从库的编号。目前，Redis 在选主库时，有一个默认的规定：**在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库**。到这里，新主库就被选出来了，“选主”这个过程就完成了。

我们再回顾下这个流程。首先，哨兵会按照在线状态、网络状态，筛选过滤掉一部分不符合要求的从库，然后，依次按照优先级、复制进度、ID 号大小再对剩余的从库进行打分，只要有得分最高的从库出现，就把它选为新主库。

配置哨兵
```shell
 sentinel monitor <master-name> <ip> <redis-port> <quorum>
```
### 基于 pub/sub 机制的哨兵集群
哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。
只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换。在主从集群中，主库上有一个名为“__sentinel__:hello”的频道，不同哨兵就是通过它来相互发现，实现互相通信的。

举个例子，哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到“__sentinel__:hello”频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653382513473-eefc2582-604e-4f9c-8c47-9076a3c69d5a.png#clientId=ud9bc8da5-4eba-4&from=paste&height=1023&id=u19df9e18&originHeight=1535&originWidth=2822&originalType=binary&ratio=1&rotation=0&showTitle=false&size=404765&status=done&style=shadow&taskId=u348d304c-c6aa-4693-b950-ab53ae74976&title=&width=1881.3333333333333)
哨兵除了彼此之间建立起连接形成集群外，还需要和从库建立连接。这是因为，在哨兵的监控任务中，它需要对主从库都进行心跳判断，而且在主从库切换完成后，它还需要通知从库，让它们和新主库进行同步。哨兵是如何知道从库的 IP 地址和端口的呢？
这是由哨兵向主库发送 INFO 命令来完成的。就像下图所示，哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1和 3 可以通过相同的方法和从库建立连接。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653382628845-6dd0b243-b8c8-49ee-ab13-7156b0f0d179.png#clientId=ud9bc8da5-4eba-4&from=paste&height=936&id=u7b09d5de&originHeight=1404&originWidth=2499&originalType=binary&ratio=1&rotation=0&showTitle=false&size=309034&status=done&style=shadow&taskId=uf50e3e45-0ec6-4751-a88e-4d0baa0276d&title=&width=1666)
但是，哨兵不能只和主、从库连接。因为，主从库切换后，客户端也需要知道新主库的连接信息，才能向新主库发送请求操作。所以，哨兵还需要完成把新主库的信息告诉客户端这个任务。客户端加入相对应事件的频道就能监听到消息了
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653383855685-446942bc-18b5-47ad-9670-4d83bb2be6ed.png#clientId=ud9bc8da5-4eba-4&from=paste&height=1159&id=u35b3aba9&originHeight=1738&originWidth=2856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=959100&status=done&style=shadow&taskId=u64b243ac-2f20-49d4-acab-f3e3dcd806f&title=&width=1904)
举个例子，你可以执行如下命令，来订阅“所有实例进入客观下线状态的事件”：
```shell
SUBSCRIBE +odown
```
订阅所有的事件：
```shell
PSUBSCRIBE *
```
当哨兵把新主库选择出来后，客户端就会看到下面的 switch-master 事件。这个事件表示主库已经切换了，新主库的 IP 地址和端口信息已经有了。这个时候，客户端就可以用这里面的新主库地址和端口进行通信了
```shell
switch-master <master name> <oldip> <oldport> <newip> <newport>
```

### 哪个哨兵执行主从切换
例如，现在有 5 个哨兵，quorum 配置的是 3，那么，一个哨兵需要 3 张赞成票，就可以标记主库为“客观下线”了。这 3 张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票。
在投票过程中，任何一个想成为 Leader 的哨兵，要满足两个条件：第一，拿到半数以上的赞成票；第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。

Redis 采用的 Raft 选举算法
哨兵投票机制：

- 哨兵实例只有在自己判定主库下线时，才会给自己投票，而其他的哨兵实例会把票投给第一个来要票的请求，其后的都拒绝
- 如果出现多个哨兵同时发现主库下线并给自己投票（小概率，每个哨兵定时器会加随机时间偏移），导致投票选举失败，就会触发新一轮投票，直至成功
> 需要注意的是，如果哨兵集群只有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，通常我们至少会配置 3 个哨兵实例。这一点很重要，你在实际应用时可不能忽略了。


## 切片集群
实际上，切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。在Redis 3.0 之前，官方并没有针对切片集群提供具体的方案。从 3.0 开始，官方提供了一个名为 Redis Cluster 的方案，用于实现切片集群。
Redis Cluster 方案采用哈希槽（Hash Slot，接下来会直接称之为 Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。
首先根据键值对的 key，按照 CRC16 算法计算一个 16 bit的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽
```shell
HASH_SLOT = CRC16(key) mod 16384
```
我们在部署 Redis Cluster 方案时，可以使用 cluster create 命令创建集群，此时，Redis会自动把这些槽平均分布在集群实例上。例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。

手动分配哈希槽
[https://redis.io/docs/reference/cluster-spec/#main-properties-and-rationales-of-the-design](https://redis.io/docs/reference/cluster-spec/#main-properties-and-rationales-of-the-design)
[https://redis.io/commands/cluster-addslots/](https://redis.io/commands/cluster-addslots/)
```shell
redis-cli -h 172.16.19.3 –p 6379 cluster addslots 0,1
redis-cli -h 172.16.19.4 –p 6379 cluster addslots 2,3
redis-cli -h 172.16.19.5 –p 6379 cluster addslots 4
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653385772856-bfcd2c19-a431-48be-82a9-e118c8a5fc9b.png#clientId=ud9bc8da5-4eba-4&from=paste&height=844&id=x77dv&originHeight=1266&originWidth=2486&originalType=binary&ratio=1&rotation=0&showTitle=false&size=415031&status=done&style=shadow&taskId=ud73adaf8-92fa-41bd-a8a1-c9ec2c64cb3&title=&width=1657.3333333333333)
在手动分配哈希槽时，需要把 16384 个槽都分配完，否则Redis 集群无法正常工作。

### 客户端如何定位数据
在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。但是，要进一步定位到实例，还需要知道哈希槽分布在哪个实例上。
Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。
客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。
但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：

- 在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；
- 为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。

Redis Cluster 方案提供了一种重定向机制，所谓的“重定向”，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。
```shell
GET hello:key
(error) MOVED 13320 172.16.19.5:6379
```
MOVED 命令表示，客户端请求的键值对所在的哈希槽 13320，实际是在172.16.19.5 这个实例上。通过返回的 MOVED 命令，就相当于把哈希槽所在的新实例的信息告诉给客户端了。这样一来，客户端就可以直接和 172.16.19.5 连接，并发送操作请求了，同时还会更新本地缓存。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653549047310-a0087c55-3d20-4524-8667-08fc04291291.png#clientId=u18744dfa-f3be-4&from=paste&height=1500&id=u92bd89f9&originHeight=2250&originWidth=2818&originalType=binary&ratio=1&rotation=0&showTitle=false&size=895425&status=done&style=shadow&taskId=u36ede020-0af4-4d6f-8326-ec919a0a347&title=&width=1878.6666666666667)
如果只是迁移了一部分数据，还没有完全迁移，此时发送请求，客户端会收到 ASK 信息
```shell
GET hello:key
(error) ASK 13320 172.16.19.5:6379
```
ASK 命令就表示，客户端请求的键值对所在的哈希槽 13320，在172.16.19.5 这个实例上，但是这个哈希槽正在迁移。此时，客户端需要先给 172.16.19.5 这个实例发送一个 ASKING 命令。这个命令的意思是，让这个实例允许执行客户端接下来发送的命令。然后，客户端再向这个实例发送 GET 命令，以读取数据。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653549317957-4a417564-d77e-40c2-b1d4-d45d99908842.png#clientId=u18744dfa-f3be-4&from=paste&height=1500&id=u11b89da9&originHeight=2250&originWidth=3000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=925003&status=done&style=shadow&taskId=ude467e8f-d0b1-4abd-9088-c85025ef689&title=&width=2000)
和 MOVED 命令不同，ASK 命令并不会更新客户端缓存的哈希槽分配信息。这也就是说，ASK 命令的作用只是让客户端能给新实例发送一次请求，而不像 MOVED 命令那样，会更改本地缓存，让后续所有命令都发往新实例。


## String类型
redis存储图片信息，使用string类型，set k1 v1，key是图片id，value是图片在对象存储系统中的id
```shell
photo_id: 1101000051
photo_obj_id: 3301000051
```
10位长度的数字，long可以装下，我们知道long是占用8个字节，key占8字节，value占8字节，理论上是占用16字节，但是实际上占用64字节。为什么呢？

---


当你保存 64 位有符号整数时，String 类型会把它保存为一个 8 字节的 Long 类型整数，这种保存方式通常也叫作 int 编码方式。
但是，当你保存的数据中包含字符时，String 类型就会用简单动态字符串（Simple Dynamic String，SDS）结构体来保存
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653622590200-46e4e807-62fe-489f-ba38-a8c0e8e3c817.png#clientId=u9a61cdfb-3539-4&from=paste&height=933&id=u1af671b4&originHeight=1400&originWidth=1926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=123198&status=done&style=shadow&taskId=ud945220a-0905-4c31-ab09-40e77f0aa75&title=&width=1284)

- buf：字节数组，保存实际数据。为了表示字节数组的结束，Redis 会自动在数组最后加一个“\0”，这就会额外占用 1 个字节的开销。
- len：占 4 个字节，表示 buf 的已用长度。
- alloc：也占个 4 字节，表示 buf 的实际分配长度，一般大于 len。

另外，对于 String 类型来说，除了 SDS 的额外开销，还有一个来自于 RedisObject 结构体的开销。
因为 Redis 的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等），所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653622726368-da004c3e-f27e-429c-abf2-36be5b351bf9.png#clientId=u9a61cdfb-3539-4&from=paste&height=1104&id=uc08721a1&originHeight=1656&originWidth=2214&originalType=binary&ratio=1&rotation=0&showTitle=false&size=190735&status=done&style=shadow&taskId=ubd0724f5-8fc7-4b86-88c5-da255d43222&title=&width=1476)
为了节省内存空间，Redis 还对 Long 类型整数和 SDS 的内存布局做了专门的设计。_在6.0版本下是这样，老版本可能不同_

- 一方面，当保存的是 Long 类型整数时，RedisObject 中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。
- 另一方面，当保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被称为 embstr 编码方式。
- 当然，当字符串大于 44 字节时，SDS 的数据量就开始变多了，Redis 就不再把 SDS 和RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 raw 编码模式。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653622826354-eee22857-4904-43b3-ba62-46906f6da4e6.png#clientId=u9a61cdfb-3539-4&from=paste&height=1292&id=u3b760d05&originHeight=1938&originWidth=3072&originalType=binary&ratio=1&rotation=0&showTitle=false&size=612597&status=done&style=shadow&taskId=u65632bcc-888f-47c6-b7cf-55ba9da7b48&title=&width=2048)
这里计算下，10 位数字的 key，可以直接使用 int 编码，可以在指针位置存值，8 字节元数据，8 位指针（实际值），16 字节。加上value 一样，就是 32 字节。还少32

Redis 会使用一个全局哈希表保存所有键值对，哈希表的每一项是一个 dictEntry 的结构体，用来指向一个键值对。dictEntry 结构中有三个 8 字节的指针，分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653624096025-aac2063f-c4c3-4314-b1d0-1b11685da483.png#clientId=u9a61cdfb-3539-4&from=paste&height=930&id=u27b938a3&originHeight=1395&originWidth=2360&originalType=binary&ratio=1&rotation=0&showTitle=false&size=326429&status=done&style=shadow&taskId=u602255d1-0ae5-4bcf-b1ff-4d0ecb05aca&title=&width=1573.3333333333333)
这里 24 字节，还少 8 字节。这就要提到 Redis 使用的内存分配库 jemalloc 了
jemalloc 在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。
举个例子。如果你申请 6 字节空间，jemalloc 实际会分配 8 字节空间；如果你申请 24 字节空间，jemalloc 则会分配 32 字节。所以，在我们刚刚说的场景里，dictEntry 结构就占用了 32 字节。
到这里就是 64 个字节了。我们想用的数据只需 16 字节，但是实际上占用了 64 字节

### 解决大量String浪费空间
Redis 有一种底层数据结构，叫压缩列表（ziplist），这是一种非常节省内存的结构。
表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量，以及列表中的 entry 个数。压缩列表尾还有一个 zlend，表示列表结束。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653632926270-12541c3e-f552-40e9-a925-01acd042bc49.png#clientId=u9a61cdfb-3539-4&from=paste&height=648&id=ubbab5d77&originHeight=972&originWidth=3457&originalType=binary&ratio=1&rotation=0&showTitle=false&size=199692&status=done&style=shadow&taskId=uacb57848-888b-4eed-a6a3-dedbd3fd18b&title=&width=2304.6666666666665)
压缩列表之所以能节省内存，就在于它是用一系列连续的 entry 保存数据。每个 entry 的元数据包括下面几部分。

- prev_len，表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。

取值 1 字节时，表示上一个 entry 的长度小于 254 字节。虽然 1 字节的值能表示的数值范围是 0 到 255，但是压缩列表中 zlend 的取值默认是 255，因此，就默认用 255表示整个压缩列表的结束，其他表示长度的地方就不能再用 255 这个值了。所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节，否则，就取值为 5 字节。

- len：表示自身长度，4 字节；
- encoding：表示编码方式，1 字节；
- content：保存实际数据。

这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。
计算下存 value 需要多少字节：value 是 long 类型，未超过254，即 prev_len = 1,content = 8。所以 1 + 4 +1 +8 = 14 字节

### 用集合保存单值的键值对
在保存单值的键值对时，可以采用基于 Hash 类型的二级编码方法。这里说的二级编码，就是把一个单值的数据拆分成两部分，前一部分作为 Hash 集合的 key，后一部分作为Hash 集合的 value，这样一来，我们就可以把单值数据保存到 Hash 集合中了。
以图片 ID 1101000060 和图片存储对象 ID 3302000080 为例，我们可以把图片 ID 的前7 位（1101000）作为 Hash 类型的键，把图片 ID 的最后 3 位（060）和图片存储对象ID 分别作为 Hash 类型值中的 key 和 value。
在使用 String 类型时，每个记录需要消耗 64 字节，这种方式却只用了 16 字节，所使用的内存空间是原来的 1/4，满足了我们节省内存空间的需求。但是查找时间却变长了
其实，二级编码方法中采用的 ID 长度是有讲究的。Hash 类型设置了用压缩列表保存数据时的两个阈值，一旦超过了阈值，Hash 类型就会用哈希表来保存数据了。

- hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。
- hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度。

如果我们往 Hash 集合中写入的元素个数超过了 hash-max-ziplist-entries，或者写入的单个元素大小超过了 hash-max-ziplist-value，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表。
一旦从压缩列表转为了哈希表，Hash 类型就会一直用哈希表进行保存，而不会再转回压缩列表了。在节省内存空间方面，哈希表就没有压缩列表那么高效了。
为了能充分使用压缩列表的精简内存布局，我们一般要控制保存在 Hash 集合中的元素个数。所以，在刚才的二级编码中，我们只用图片 ID 最后 3 位作为 Hash 集合的 key（最大值999），也就保证了 Hash 集合的元素个数不超过 1000，同时，我们把 hash-max-ziplist-entries 设置为 1000，这样一来，Hash 集合就可以一直使用压缩列表来节省内存空间了。
> 不同版本，底层数据结构不一样，压缩的空间也就不一样

```shell
127.0.0.1:6379> hset 1101001 061 3302000081
(integer) 1
127.0.0.1:6379> info memory
# Memory
used_memory:872712
127.0.0.1:6379> hset 1101001 062 3302000082
(integer) 1
127.0.0.1:6379> info memory
# Memory
used_memory:872728
```

## CPU对Redis的影响
### 主流的 CPU 架构
**CPU socket**
cpu 插槽，家用电脑一般都是一个，可能服务器是多个插槽
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653895935490-ae8c40f4-b932-464c-95c9-56c7b6c003fb.png#clientId=u9c321140-a9b9-4&from=paste&id=ue8b81575&originHeight=720&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&size=1197730&status=done&style=shadow&taskId=ufa625dbe-ea4f-4764-be6f-555be73378d&title=)
**Core**
一个 CPU 处理器中一般有多个运行核心，我们把一个运行核心称为一个物理核，每个物理核都可以运行应用程序。每个物理核都拥有私有的一级缓存（Level 1 cache，简称 L1 cache），包括一级指令缓存和一级数据缓存，以及私有的二级缓存（Level 2 cache，简称 L2 cache）。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653896075414-ceba804e-dfa3-48ef-8068-b8eb63e19547.png#clientId=u9c321140-a9b9-4&from=paste&id=ud14ad11a&originHeight=669&originWidth=1080&originalType=url&ratio=1&rotation=0&showTitle=false&size=550716&status=done&style=shadow&taskId=u4779b0ef-5050-435a-a8db-28e48179e0a&title=)
现在主流的 CPU 处理器中，每个物理核通常都会运行两个超线程，也叫作逻辑核。同一个物理核的逻辑核会共享使用 L1、L2 缓存。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653896138720-9f20d00a-6207-4847-90f6-c3a17e5ded7a.png#clientId=u9c321140-a9b9-4&from=paste&height=1089&id=u7a31caf0&originHeight=1633&originWidth=3065&originalType=binary&ratio=1&rotation=0&showTitle=false&size=545600&status=done&style=shadow&taskId=u8f7aefcc-d83c-4de3-aa6e-d3f276fc523&title=&width=2043.3333333333333)
_**单颗 CPU**_
在主流的服务器上，一个 CPU 处理器会有 10 到 20 多个物理核。同时，为了提升服务器的处理能力，服务器上通常还会有多个 CPU 处理器（也称为多 CPU Socket），每个处理器有自己的物理核（包括 L1、L2 缓存），L3 缓存，以及连接的内存，同时，不同处理器间通过总线连接。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653896437937-81d3a3d7-c7d5-4e99-bfbd-fbb1a55c62b4.png#clientId=u9c321140-a9b9-4&from=paste&height=835&id=u6629a9d0&originHeight=1252&originWidth=3000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=226183&status=done&style=shadow&taskId=ua6212202-e260-45b5-881c-48c35273bdd&title=&width=2000)
**_多颗 CPU_**
**在多 CPU 架构上，应用程序可以在不同的处理器上运行**。Redis 可以先在 Socket 1 上运行一段时间，然后再被调度到 Socket 2 上运行。但是：如果应用程序先在一个 Socket 上运行，并且把数据保存到了内存，然后被调度到另一个 Socket 上运行，此时，应用程序再进行内存访问时，就需要访问之前 Socket 上连接的内存，这种访问属于**远端内存访问。和访问 Socket 直接连接的内存相比，远端内存访问会增加应用程序的延迟**。
**NUMA **
在多 CPU 架构下，一个应用程序访问所在 Socket 的本地内存和访问远端内存的延迟并不一致，所以，我们也把这个架构称为非统一内存访问架构（Non-Uniform MemoryAccess，NUMA 架构）。

L1、L2 缓存中的指令和数据的访问速度很快，所以，充分利用 L1、L2 缓存，可以有效缩短应用程序的执行时间；
在 NUMA 架构下，如果应用程序从一个 Socket 上调度到另一个 Socket 上，就可能会出现远端内存访问的情况，这会直接增加应用程序的执行时间。

在一个 CPU 核上运行时，应用程序需要记录自身使用的软硬件资源信息（例如栈指针、CPU 核的寄存器值等），我们把这些信息称为**运行时信息**。同时，应用程序访问最频繁的指令和数据还会被缓存到 L1、L2 缓存上，以便提升执行速度。
如果在 CPU 多核场景下，Redis 实例被频繁调度到不同 CPU 核上运行的话，**每调度一次，一些请求就会受到运行时信息、指令和数据重新加载过程的影响，这就会导致某些请求的延迟明显高于其他请求。**
我们可以使用 `taskset`命令把一个程序绑定在一个核上运行。
```shell
# 把 Redis 实例绑在了 0 号核上
taskset -c 0 ./redis-server
```

### NUMA 架构对 Redis 性能的影响
Redis 实例和网络中断程序的数据交互：
网络中断处理程序从网卡硬件中读取数据，并把数据写入到操作系统内核维护的一块内存缓冲区。内核会通过 epoll 机制触发事件，通知 Redis 实例，Redis 实例再把数据从内核的内存缓冲区拷贝到自己的内存空间
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653896971232-998edb8d-35c2-4591-a51a-992293f7e18b.png#clientId=u9c321140-a9b9-4&from=paste&height=863&id=u3ade0516&originHeight=1295&originWidth=2108&originalType=binary&ratio=1&rotation=0&showTitle=false&size=298661&status=done&style=shadow&taskId=u2cfed4f5-e9d8-44ba-a5bd-9e8c84d3719&title=&width=1405.3333333333333)
那么，在 CPU 的 NUMA 架构下，当网络中断处理程序、Redis 实例分别和 CPU 核绑定后，就会有一个潜在的风险：**如果网络中断处理程序和 Redis 实例各自所绑的 CPU 核不在同一个 CPU Socket 上，那么，Redis 实例读取网络数据时，就需要跨 CPU Socket 访问内存，这个过程会花费较多时间**。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653897035544-1776c1ff-4636-4308-8bf0-de1d1e48b81a.png#clientId=u9c321140-a9b9-4&from=paste&height=834&id=uc6edc05a&originHeight=1251&originWidth=3000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=262252&status=done&style=shadow&taskId=u0ce89503-f98c-4ebd-8965-797e8d50c68&title=&width=2000)
为了避免 Redis 跨 CPU Socket 访问网络数据，我们最好把网络中断程序和 Redis 实例绑在同一个 CPU Socket 上，这样一来，Redis 实例就可以直接从本地内存读取网络数据了
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653897071379-af5a7d68-c79f-43fc-b30b-5900db3e8c48.png#clientId=u9c321140-a9b9-4&from=paste&height=986&id=u966dbb2d&originHeight=1479&originWidth=2874&originalType=binary&ratio=1&rotation=0&showTitle=false&size=371958&status=done&style=shadow&taskId=uf0ee931b-0853-4c1d-bc0f-e81c9cee8dc&title=&width=1916)
**在 CPU 的 NUMA 架构下，对 CPU 核的编号规则，并不是先把一个 CPU Socket 中的所有逻辑核编完，再对下一个 CPU Socket 中的逻辑核编码，而是先给每个 CPU Socket 中每个物理核的第一个逻辑核依次编号，再给每个 CPU Socket 中的物理核的第二个逻辑核依次编号**
假设有 2 个 CPU Socket，每个 Socket 上有 6 个物理核，每个物理核又有 2 个逻辑核，总共 24 个逻辑核
```shell
lscpu
Architecture: x86_64
...
NUMA node0 CPU(s): 0-5,12-17
NUMA node1 CPU(s): 6-11,18-23
...
```
可以看到，NUMA node0 的 CPU 核编号是 0 到 5、12 到 17。其中，0 到 5 是 node0上的 6 个物理核中的第一个逻辑核的编号，12 到 17 是相应物理核中的第二个逻辑核编号。NUMA node1 的 CPU 核编号规则和 node0 一样。
**所以，一定要注意 NUMA 架构下 CPU 核的编号方法，这样才不会绑错核。**

### 绑核的风险和解决方案
当我们把 Redis 实例绑到一个 CPU 逻辑核上时，就会导致子进程、后台线程和 Redis 主线程竞争 CPU 资源，一旦子进程或后台线程占用 CPU 时，主线程就会被阻塞，导致Redis 请求延迟增加。
针对这种情况，这里有两种解决方案，分别是**一个 Redis 实例对应绑一个物理核**和优化 Redis 源码。
**在给 Redis 实例绑核时，我们不要把一个实例和一个逻辑核绑定，而要和一个物理核绑定，也就是说，把一个物理核的 2 个逻辑核都用上。**
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653963248251-59e70308-336c-486e-ae8e-52352c309fb8.png#clientId=u53fc7181-5269-4&from=paste&height=531&id=ubbcbd093&originHeight=796&originWidth=1352&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36585&status=done&style=shadow&taskId=u129d87e0-8a0b-4816-8ddf-a9ceab58725&title=&width=901.3333333333334)
以刚才的 NUMA 架构为例，NUMA node0 的 CPU 核编号是 0 ~ 5、12 ~17。其中，编号 0 和 12、1 和 13、2 和 14 等都是表示一个物理核的 2 个逻辑核。执行
下面的命令，就把 Redis 实例绑定到了逻辑核 0 和 12 上，而这两个核正好都属于物理核1。
```shell
taskset -c 0,12 ./redis-server
```
和只绑一个逻辑核相比，把 Redis 实例和物理核绑定，可以让主线程、子进程、后台线程共享使用 2 个逻辑核，可以在一定程度上缓解 CPU 资源竞争。但是，因为只用了 2 个逻辑核，它们相互之间的 CPU 竞争仍然还会存在。如果还想进一步减少 CPU 竞争，还要优化 Redis 源码

## 波动延迟
### 服务器端软硬件环境的影响
```shell
root@602aa413f35e:/data# redis-cli --intrinsic-latency 120
Max latency so far: 1 microseconds.
Max latency so far: 17 microseconds.
Max latency so far: 26 microseconds.
Max latency so far: 29 microseconds.
Max latency so far: 38 microseconds.
Max latency so far: 52 microseconds.
Max latency so far: 85 microseconds.
Max latency so far: 132 microseconds.
Max latency so far: 134 microseconds.
Max latency so far: 759 microseconds.

2359708972 total runs (avg latency: 0.0509 microseconds / 50.85 nanoseconds per run).
Worst run took 14925x longer than the average latency.
```

### Redis 自身操作特性的影响
Redis 自身的操作特性、文件系统和操作系统，它们是影响 Redis 性能的三大要素
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653966544867-94ec7d47-0ab9-4414-a93e-2c920388d347.png#clientId=uc67f1b9b-5b9b-4&from=paste&height=2026&id=uf31a7070&originHeight=3039&originWidth=4242&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1178233&status=done&style=shadow&taskId=u0a26b8c9-d466-4352-91e5-b877f50fdab&title=&width=2828)

1. 慢查询命令
- 用其他高效命令代替。如不要使用keys查询所有key，可以使用scan进行查询，不会阻塞线程
- 当你需要执行排序、交集、并集操作时，可以在客户端完成，而不要用 SORT、SUNION、SINTER 这些命令，以免拖慢 Redis 实例。
2. 过期 key 操作
- redis本身的内存回收机制会造成redis操作阻塞，导致性能变慢（Redis 4.0 后可以用异步线程机制来减少阻塞影响）
- 导致原因：大批量的key同时间内过期，导致删除过期key的机制一直触发，引起redis操作阻塞
- 解决方法：对key设定过期时间时，添加一个删除的时间随机数，能避免key存在同一时间过期

redis删除过期key的机制，每100毫秒对一些key进行删除。算法如下

1. 采样 `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` 个数的 key，并将其中过期的 key 全部删除；(默认20，就是1s删除200个过期的key)
2. 如果超过 25% 的 key 过期了，则重复删除的过程，直到过期 key 的比例降至 25% 以下。

> scan 过程过程中发生 rehash 导致数据重复？
> [https://blog.csdn.net/u014439693/article/details/108325632](https://blog.csdn.net/u014439693/article/details/108325632)

### 文件系统：AOF 模式
AOF日志提供了三种日志写回策略：no、everysec、always。这三种写回策略依赖文件系统的两个系统调用完成，也就是 write 和 fsync。write 只要把日志记录写到内核缓冲区，就可以返回了，并不需要等待日志实际写回到磁盘；而 fsync 需要把日志记录写回到磁盘后才能返回，时间较长。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653979303483-0784c5be-f521-4d27-b405-a7003dddc3b3.png#clientId=u2ce0847d-1d97-4&from=paste&height=266&id=ud9ec0f5e&originHeight=598&originWidth=2720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=448631&status=done&style=shadow&taskId=u4d0b20b2-bfee-4f7e-aa8e-30b0f8d8b4b&title=&width=1208.888888888889)

- 当写回策略配置为 everysec 时，Redis 会使用后台的子线程异步完成 fsync 的操作。
- always 需要确保每个操作记录日志都写回磁盘，如果用后台子线程异步完成，主线程就无法及时地知道每个操作是否已经完成了，这就不符合 always 策略的要求了。所以，always 策略并不使用后台子线程来执行。
- Redis 使用子进程来进行 AOF 重写

当主线程使用后台子线程执行了一次 fsync，需要再次把新接收的操作记录写回磁盘时，如果主线程发现上一次的 fsync 还没有执行完，那么它就会阻塞。所以，如果后台子线程执行的 fsync 频繁阻塞的话（比如 AOF 重写占用了大量的磁盘 IO 带宽），主线程也会阻塞，导致 Redis 性能变慢。
![image.png](https://cdn.nlark.com/yuque/0/2022/png/21889008/1653979448522-06b915d3-6d38-40bf-b1f0-d91d1abda09d.png#clientId=u2ce0847d-1d97-4&from=paste&height=692&id=u3cdb2896&originHeight=1557&originWidth=3000&originalType=binary&ratio=1&rotation=0&showTitle=false&size=588819&status=done&style=shadow&taskId=u13219817-6dd2-4c8f-9052-a499dfe042d&title=&width=1333.3333333333333)
由于 fsync 后台子线程和 AOF 重写子进程的存在，主IO 线程一般不会被阻塞。但是，如果在重写日志时，AOF 重写子进程的写入量比较大，fsync 线程也会被阻塞，进而阻塞主线程，导致延迟增加

```shell
no-appendfsync-on-rewrite yes
```
这个配置项设置为 yes 时，表示在 AOF 重写时，不进行 fsync 操作。

- 也就是说，Redis 实例把写命令写到内存后，不调用后台线程进行 fsync 操作，就可以直接返回了。当然，如果此时实例发生宕机，就会导致数据丢失。
- 反之，如果这个配置项设置为 no（也是默认配置），在 AOF 重写时，Redis 实例仍然会调用后台线程进行 fsync 操作，这就会给实例带来阻塞

### 总结
[https://redis.io/docs/reference/optimization/](https://redis.io/docs/reference/optimization/)

1. 获取 Redis 实例在当前环境下的基线性能。
2. 是否用了慢查询命令？如果是的话，就使用其他命令替代慢查询命令，或者把聚合计算命令放在客户端做。
3. 是否对过期 key 设置了相同的过期时间？对于批量删除的 key，可以在每个 key 的过期时间上加一个随机数，避免同时删除。
4. 是否存在 bigkey？ 对于 bigkey 的删除操作，如果你的 Redis 是 4.0 及以上的版本，可以直接利用异步线程机制减少主线程阻塞；如果是 Redis 4.0 以前的版本，可以使用SCAN 命令迭代删除；对于 bigkey 的集合查询和聚合操作，可以使用 `SCAN` 命令在客户端完成。
5. Redis AOF 配置级别是什么？业务层面是否的确需要这一可靠性级别？如果我们需要高性能，同时也允许数据丢失，可以将配置项 `no-appendfsync-on-rewrite` 设置为yes，避免 AOF 重写和 fsync 竞争磁盘 IO 资源，导致 Redis 延迟增加。当然， 如果既需要高性能又需要高可靠性，最好使用高速固态盘作为 AOF 日志的写入盘。
6. Redis 实例的内存使用是否过大？发生 swap 了吗？如果是的话，就增加机器内存，或者是使用 Redis 集群，分摊单机 Redis 的键值对数量和内存压力。同时，要避免出现Redis 和其他内存需求大的应用共享机器的情况。
7. 在 Redis 实例的运行环境中，是否启用了透明大页机制？如果是的话，直接关闭内存大页机制就行了
8. 是否运行了 Redis 主从集群？如果是的话，把主库实例的数据量大小控制在 2~4GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞。
9. 是否使用了多核 CPU 或 NUMA 架构的机器运行 Redis 实例？使用多核 CPU 时，可以给 Redis 实例绑定物理核；使用 NUMA 架构时，注意把 Redis 实例和网络中断处理程序运行在同一个 CPU Socket 上。


## 内存碎片
### 内存分配方式
jemalloc 的分配策略之一，是按照一系列固定的大小划分内存空间，例如 8 字节、16 字节、32 字节、48 字节，…, 2KB、4KB、8KB 等。当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间。
这样的分配方式本身是为了减少分配次数。例如，Redis 申请一个 20 字节的空间保存数据，jemalloc 就会分配 32 字节，此时，如果应用还要写入 10 字节的数据，Redis 就不用再向操作系统申请空间了，因为刚才分配的 32 字节已经够用了，这就避免了一次分配操作。

### 识别内存碎片
```shell
INFO memory
# Memory
used_memory:1073741736
used_memory_human:1024.00M
used_memory_rss:1997159792
used_memory_rss_human:1.86G
…
mem_fragmentation_ratio:1.86
```
mem_fragmentation_ratio 它表示的就是 Redis 当前的内存碎片率
`mem_fragmentation_ratio = used_memory_rss/ used_memory`

- `used_memory_rss`是操作系统实际分配给 Redis 的物理内存空间，里面就包含了碎片；
-  `used_memory`是 Redis 为了保存数据实际申请使用的空间。

例如，Redis 申请使用了 100 字节（used_memory），操作系统实际分配了 128 字节（used_memory_rss），此时，mem_fragmentation_ratio 就是1.28。

- **mem_fragmentation_ratio 大于 1 但小于 1.5。这种情况是合理的。**这是因为，刚才我介绍的那些因素是难以避免的。毕竟，内因的内存分配器是一定要使用的，分配策略都是通用的，不会轻易修改；而外因由 Redis 负载决定，也无法限制。所以，存在内存碎片也是正常的。
- **mem_fragmentation_ratio 大于 1.5 。这表明内存碎片率已经超过了 50%。**一般情况下，这个时候，我们就需要采取一些措施来降低内存碎片率了。

### 清理内存碎片
4.0-RC3 版本以后，Redis 自身提供了一种内存碎片自动清理的方法
开启自动清理
```shell
config set activedefrag yes
```
清理内存碎片是阻塞操作，可以进行相关配置
```shell
# 内存碎片的字节数达到 100MB 时，开始清理
active-defrag-ignore-bytes 100mb
# 表示内存碎片空间占操作系统分配给 Redis 的总空间比例达到 10% 时，开始清理。
#（第一个和第二个需要同时满足才会开始清理）
active-defrag-threshold-lower 10
# 表示自动清理过程所用 CPU 时间的比例不低于 25%，保证清理能正常开展
active-defrag-cycle-min 25
# 表示自动清理过程所用 CPU 时间的比例不高于 75%，一旦超过，就停止清理，
# 从而避免在清理时，大量的内存拷贝阻塞 Redis，导致响应延迟升高。
active-defrag-cycle-max 75
```


